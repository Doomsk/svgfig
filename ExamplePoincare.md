_(This page applies only to the 1.x branch of SVGFig.)_

# Square on the Poincaré disk #

(Okay, so it's not actually a _square_, because the sides are not [geodesics](http://en.wikipedia.org/wiki/Geodesic) on the hyperbolic plane.  But to my Euclidean eyes, the middle one looks like a square!)

This is a grand example of recursion self-similarity: a tiling of the [hyperbolic plane](http://en.wikipedia.org/wiki/Hyperbolic_plane), represented by the [Poincaré disk](http://en.wikipedia.org/wiki/Poincare_disk) (one of M.C. Escher's favorite paradigms).  The same [Path](ClassPath.md) is drawn 5 iterations deep, transformed with the appropriate [Möbius transformation](http://en.wikipedia.org/wiki/M%C3%B6bius_transformation).  This is perhaps the simplest case, in which the tiles are generated by the [free group](http://en.wikipedia.org/wiki/Free_group).

Yes, I just learned a little [Riemannian geometry](http://en.wikipedia.org/wiki/Riemannian_geometry) and was itching to draw this.

```
from svgfig import *
import math

def one(z): return (z + (1+1j)/2.) / ((1-1j)*z/2. + 1)
def two(z): return (z + -(1-1j)/2.) / (-(1+1j)*z/2. + 1)
def three(z): return (z - (1+1j)/2.) / (-(1-1j)*z/2. + 1)
def four(z): return (z + (1-1j)/2.) / ((1+1j)*z/2. + 1)

def recurse(t, direction, depth=0):
  if depth == 5: return Fig()

  if direction == one:
    return Fig(t, recurse(t, two, depth+1), recurse(t, one, depth+1), recurse(t, four, depth+1), trans=totrans(one))

  if direction == two:
    return Fig(t, recurse(t, three, depth+1), recurse(t, two, depth+1), recurse(t, one, depth+1), trans=totrans(two))

  if direction == three:
    return Fig(t, recurse(t, four, depth+1), recurse(t, three, depth+1), recurse(t, two, depth+1), trans=totrans(three))

  if direction == four:
    return Fig(t, recurse(t, one, depth+1), recurse(t, four, depth+1), recurse(t, three, depth+1), trans=totrans(four))

x = 1. - math.sqrt(0.5)
tile = Path("M -%g -%g L -%g %g L %g %g L %g -%g Z" % ((x,) * 8), fill="purple")

Fig(Ellipse(0, 0, 0, 1, 1, fill="lightgreen"), \
    tile, \
    recurse(tile, one), \
    recurse(tile, two), \
    recurse(tile, three), \
    recurse(tile, four)).SVG(window(-1.1, 1.1, -1.1, 1.1)).inkview()
```

### Comments ###

  * Note that we could have loaded a 

&lt;path /&gt;

 from a file: we can tile the hyperbolic plane with _anything!_

  * Only the vertices are transformed, not the edges of the [Path](ClassPath.md).  We could have replaced the [Path](ClassPath.md) with a [Rect](ClassRect.md).  That would have curved the edges, but it takes a long time.  Perhaps the adaptive sampling algorithm could be optimized or compiled.

| ![![](http://svgfig.googlecode.com/svn/wiki/ExamplePoincare.png)](http://svgfig.googlecode.com/svn/wiki/ExamplePoincare.svg) |
|:-----------------------------------------------------------------------------------------------------------------------------|
| [ExamplePoincare.svg](http://svgfig.googlecode.com/svn/wiki/ExamplePoincare.svg) |